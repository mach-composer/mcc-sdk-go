/*
MACH composer Cloud (MCC) Public API

# Introduction  MACH composer Cloud is a platform and API to facilitate and coordinate work across teams that build composable architectures using MACH technology.  All operations available in MACH composer cloud are available through this API. For more information about using it in your MACH architecture, have a look at the [documentation website](https://docs.machcomposer.io/cloud/index.html).

API version: 0.1.0
Contact: mach@labdigital.nl
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mccsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type ComponentsApi interface {

	/*
		ComponentCreate Create component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@return ApiComponentCreateRequest
	*/
	ComponentCreate(ctx context.Context, organization string, project string) ApiComponentCreateRequest

	// ComponentCreateExecute executes the request
	//  @return Component
	ComponentCreateExecute(r ApiComponentCreateRequest) (*Component, *http.Response, error)

	/*
		ComponentLatestVersion Get last component version

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@return ApiComponentLatestVersionRequest
	*/
	ComponentLatestVersion(ctx context.Context, organization string, project string, component string) ApiComponentLatestVersionRequest

	// ComponentLatestVersionExecute executes the request
	//  @return ComponentVersion
	ComponentLatestVersionExecute(r ApiComponentLatestVersionRequest) (*ComponentVersion, *http.Response, error)

	/*
		ComponentPatch Patch an existing component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@return ApiComponentPatchRequest
	*/
	ComponentPatch(ctx context.Context, organization string, project string, component string) ApiComponentPatchRequest

	// ComponentPatchExecute executes the request
	//  @return Component
	ComponentPatchExecute(r ApiComponentPatchRequest) (*Component, *http.Response, error)

	/*
		ComponentQuery List all components

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@return ApiComponentQueryRequest
	*/
	ComponentQuery(ctx context.Context, organization string, project string) ApiComponentQueryRequest

	// ComponentQueryExecute executes the request
	//  @return ComponentPaginator
	ComponentQueryExecute(r ApiComponentQueryRequest) (*ComponentPaginator, *http.Response, error)

	/*
		ComponentVersionCreate Create component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@return ApiComponentVersionCreateRequest
	*/
	ComponentVersionCreate(ctx context.Context, organization string, project string, component string) ApiComponentVersionCreateRequest

	// ComponentVersionCreateExecute executes the request
	//  @return ComponentVersion
	ComponentVersionCreateExecute(r ApiComponentVersionCreateRequest) (*ComponentVersion, *http.Response, error)

	/*
		ComponentVersionDelete Delete component version

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@param version Version
		@return ApiComponentVersionDeleteRequest
	*/
	ComponentVersionDelete(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionDeleteRequest

	// ComponentVersionDeleteExecute executes the request
	//  @return ComponentVersion
	ComponentVersionDeleteExecute(r ApiComponentVersionDeleteRequest) (*ComponentVersion, *http.Response, error)

	/*
		ComponentVersionGet Get component version

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@param version Version
		@return ApiComponentVersionGetRequest
	*/
	ComponentVersionGet(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionGetRequest

	// ComponentVersionGetExecute executes the request
	//  @return ComponentVersion
	ComponentVersionGetExecute(r ApiComponentVersionGetRequest) (*ComponentVersion, *http.Response, error)

	/*
		ComponentVersionPushCommits Push commits for this component version

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@param version Component version
		@return ApiComponentVersionPushCommitsRequest
	*/
	ComponentVersionPushCommits(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionPushCommitsRequest

	// ComponentVersionPushCommitsExecute executes the request
	ComponentVersionPushCommitsExecute(r ApiComponentVersionPushCommitsRequest) (*http.Response, error)

	/*
		ComponentVersionQuery List all versions of a component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@return ApiComponentVersionQueryRequest
	*/
	ComponentVersionQuery(ctx context.Context, organization string, project string, component string) ApiComponentVersionQueryRequest

	// ComponentVersionQueryExecute executes the request
	//  @return ComponentVersionPaginator
	ComponentVersionQueryExecute(r ApiComponentVersionQueryRequest) (*ComponentVersionPaginator, *http.Response, error)

	/*
		ComponentVersionQueryCommits Get commits for this component version

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organization Organization Key
		@param project Project Key
		@param component Component key
		@param version Component version
		@return ApiComponentVersionQueryCommitsRequest
	*/
	ComponentVersionQueryCommits(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionQueryCommitsRequest

	// ComponentVersionQueryCommitsExecute executes the request
	//  @return CommitDataPaginator
	ComponentVersionQueryCommitsExecute(r ApiComponentVersionQueryCommitsRequest) (*CommitDataPaginator, *http.Response, error)
}

// ComponentsApiService ComponentsApi service
type ComponentsApiService service

type ApiComponentCreateRequest struct {
	ctx            context.Context
	ApiService     ComponentsApi
	organization   string
	project        string
	componentDraft *ComponentDraft
}

func (r ApiComponentCreateRequest) ComponentDraft(componentDraft ComponentDraft) ApiComponentCreateRequest {
	r.componentDraft = &componentDraft
	return r
}

func (r ApiComponentCreateRequest) Execute() (*Component, *http.Response, error) {
	return r.ApiService.ComponentCreateExecute(r)
}

/*
ComponentCreate Create component

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@return ApiComponentCreateRequest
*/
func (a *ComponentsApiService) ComponentCreate(ctx context.Context, organization string, project string) ApiComponentCreateRequest {
	return ApiComponentCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
	}
}

// Execute executes the request
//
//	@return Component
func (a *ComponentsApiService) ComponentCreateExecute(r ApiComponentCreateRequest) (*Component, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Component
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentDraft == nil {
		return localVarReturnValue, nil, reportError("componentDraft is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.componentDraft
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentLatestVersionRequest struct {
	ctx          context.Context
	ApiService   ComponentsApi
	organization string
	project      string
	component    string
	branch       *string
}

func (r ApiComponentLatestVersionRequest) Branch(branch string) ApiComponentLatestVersionRequest {
	r.branch = &branch
	return r
}

func (r ApiComponentLatestVersionRequest) Execute() (*ComponentVersion, *http.Response, error) {
	return r.ApiService.ComponentLatestVersionExecute(r)
}

/*
ComponentLatestVersion Get last component version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@return ApiComponentLatestVersionRequest
*/
func (a *ComponentsApiService) ComponentLatestVersion(ctx context.Context, organization string, project string, component string) ApiComponentLatestVersionRequest {
	return ApiComponentLatestVersionRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
	}
}

// Execute executes the request
//
//	@return ComponentVersion
func (a *ComponentsApiService) ComponentLatestVersionExecute(r ApiComponentLatestVersionRequest) (*ComponentVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentLatestVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.branch == nil {
		return localVarReturnValue, nil, reportError("branch is required and must be specified")
	}

	localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentPatchRequest struct {
	ctx               context.Context
	ApiService        ComponentsApi
	organization      string
	project           string
	component         string
	patchRequestInner *[]PatchRequestInner
}

func (r ApiComponentPatchRequest) PatchRequestInner(patchRequestInner []PatchRequestInner) ApiComponentPatchRequest {
	r.patchRequestInner = &patchRequestInner
	return r
}

func (r ApiComponentPatchRequest) Execute() (*Component, *http.Response, error) {
	return r.ApiService.ComponentPatchExecute(r)
}

/*
ComponentPatch Patch an existing component

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@return ApiComponentPatchRequest
*/
func (a *ComponentsApiService) ComponentPatch(ctx context.Context, organization string, project string, component string) ApiComponentPatchRequest {
	return ApiComponentPatchRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
	}
}

// Execute executes the request
//
//	@return Component
func (a *ComponentsApiService) ComponentPatchExecute(r ApiComponentPatchRequest) (*Component, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Component
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentQueryRequest struct {
	ctx          context.Context
	ApiService   ComponentsApi
	organization string
	project      string
	offset       *int32
	limit        *int32
	sort         *[]string
}

func (r ApiComponentQueryRequest) Offset(offset int32) ApiComponentQueryRequest {
	r.offset = &offset
	return r
}

func (r ApiComponentQueryRequest) Limit(limit int32) ApiComponentQueryRequest {
	r.limit = &limit
	return r
}

func (r ApiComponentQueryRequest) Sort(sort []string) ApiComponentQueryRequest {
	r.sort = &sort
	return r
}

func (r ApiComponentQueryRequest) Execute() (*ComponentPaginator, *http.Response, error) {
	return r.ApiService.ComponentQueryExecute(r)
}

/*
ComponentQuery List all components

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@return ApiComponentQueryRequest
*/
func (a *ComponentsApiService) ComponentQuery(ctx context.Context, organization string, project string) ApiComponentQueryRequest {
	return ApiComponentQueryRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
	}
}

// Execute executes the request
//
//	@return ComponentPaginator
func (a *ComponentsApiService) ComponentQueryExecute(r ApiComponentQueryRequest) (*ComponentPaginator, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentPaginator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentVersionCreateRequest struct {
	ctx                   context.Context
	ApiService            ComponentsApi
	organization          string
	project               string
	component             string
	componentVersionDraft *ComponentVersionDraft
}

func (r ApiComponentVersionCreateRequest) ComponentVersionDraft(componentVersionDraft ComponentVersionDraft) ApiComponentVersionCreateRequest {
	r.componentVersionDraft = &componentVersionDraft
	return r
}

func (r ApiComponentVersionCreateRequest) Execute() (*ComponentVersion, *http.Response, error) {
	return r.ApiService.ComponentVersionCreateExecute(r)
}

/*
ComponentVersionCreate Create component

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@return ApiComponentVersionCreateRequest
*/
func (a *ComponentsApiService) ComponentVersionCreate(ctx context.Context, organization string, project string, component string) ApiComponentVersionCreateRequest {
	return ApiComponentVersionCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
	}
}

// Execute executes the request
//
//	@return ComponentVersion
func (a *ComponentsApiService) ComponentVersionCreateExecute(r ApiComponentVersionCreateRequest) (*ComponentVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentVersionCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentVersionDraft == nil {
		return localVarReturnValue, nil, reportError("componentVersionDraft is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.componentVersionDraft
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentVersionDeleteRequest struct {
	ctx          context.Context
	ApiService   ComponentsApi
	organization string
	project      string
	component    string
	version      string
}

func (r ApiComponentVersionDeleteRequest) Execute() (*ComponentVersion, *http.Response, error) {
	return r.ApiService.ComponentVersionDeleteExecute(r)
}

/*
ComponentVersionDelete Delete component version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@param version Version
	@return ApiComponentVersionDeleteRequest
*/
func (a *ComponentsApiService) ComponentVersionDelete(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionDeleteRequest {
	return ApiComponentVersionDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
		version:      version,
	}
}

// Execute executes the request
//
//	@return ComponentVersion
func (a *ComponentsApiService) ComponentVersionDeleteExecute(r ApiComponentVersionDeleteRequest) (*ComponentVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentVersionDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentVersionGetRequest struct {
	ctx          context.Context
	ApiService   ComponentsApi
	organization string
	project      string
	component    string
	version      string
}

func (r ApiComponentVersionGetRequest) Execute() (*ComponentVersion, *http.Response, error) {
	return r.ApiService.ComponentVersionGetExecute(r)
}

/*
ComponentVersionGet Get component version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@param version Version
	@return ApiComponentVersionGetRequest
*/
func (a *ComponentsApiService) ComponentVersionGet(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionGetRequest {
	return ApiComponentVersionGetRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
		version:      version,
	}
}

// Execute executes the request
//
//	@return ComponentVersion
func (a *ComponentsApiService) ComponentVersionGetExecute(r ApiComponentVersionGetRequest) (*ComponentVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentVersionPushCommitsRequest struct {
	ctx                     context.Context
	ApiService              ComponentsApi
	organization            string
	project                 string
	component               string
	version                 string
	componentVersionCommits *ComponentVersionCommits
}

func (r ApiComponentVersionPushCommitsRequest) ComponentVersionCommits(componentVersionCommits ComponentVersionCommits) ApiComponentVersionPushCommitsRequest {
	r.componentVersionCommits = &componentVersionCommits
	return r
}

func (r ApiComponentVersionPushCommitsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ComponentVersionPushCommitsExecute(r)
}

/*
ComponentVersionPushCommits Push commits for this component version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@param version Component version
	@return ApiComponentVersionPushCommitsRequest
*/
func (a *ComponentsApiService) ComponentVersionPushCommits(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionPushCommitsRequest {
	return ApiComponentVersionPushCommitsRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
		version:      version,
	}
}

// Execute executes the request
func (a *ComponentsApiService) ComponentVersionPushCommitsExecute(r ApiComponentVersionPushCommitsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentVersionPushCommits")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}/versions/{version}/commits"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentVersionCommits == nil {
		return nil, reportError("componentVersionCommits is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.componentVersionCommits
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiComponentVersionQueryRequest struct {
	ctx          context.Context
	ApiService   ComponentsApi
	organization string
	project      string
	component    string
	offset       *int32
	limit        *int32
	sort         *[]string
}

func (r ApiComponentVersionQueryRequest) Offset(offset int32) ApiComponentVersionQueryRequest {
	r.offset = &offset
	return r
}

func (r ApiComponentVersionQueryRequest) Limit(limit int32) ApiComponentVersionQueryRequest {
	r.limit = &limit
	return r
}

func (r ApiComponentVersionQueryRequest) Sort(sort []string) ApiComponentVersionQueryRequest {
	r.sort = &sort
	return r
}

func (r ApiComponentVersionQueryRequest) Execute() (*ComponentVersionPaginator, *http.Response, error) {
	return r.ApiService.ComponentVersionQueryExecute(r)
}

/*
ComponentVersionQuery List all versions of a component

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@return ApiComponentVersionQueryRequest
*/
func (a *ComponentsApiService) ComponentVersionQuery(ctx context.Context, organization string, project string, component string) ApiComponentVersionQueryRequest {
	return ApiComponentVersionQueryRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
	}
}

// Execute executes the request
//
//	@return ComponentVersionPaginator
func (a *ComponentsApiService) ComponentVersionQueryExecute(r ApiComponentVersionQueryRequest) (*ComponentVersionPaginator, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentVersionPaginator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentVersionQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentVersionQueryCommitsRequest struct {
	ctx          context.Context
	ApiService   ComponentsApi
	organization string
	project      string
	component    string
	version      string
	offset       *int32
	limit        *int32
	sort         *[]string
}

func (r ApiComponentVersionQueryCommitsRequest) Offset(offset int32) ApiComponentVersionQueryCommitsRequest {
	r.offset = &offset
	return r
}

func (r ApiComponentVersionQueryCommitsRequest) Limit(limit int32) ApiComponentVersionQueryCommitsRequest {
	r.limit = &limit
	return r
}

func (r ApiComponentVersionQueryCommitsRequest) Sort(sort []string) ApiComponentVersionQueryCommitsRequest {
	r.sort = &sort
	return r
}

func (r ApiComponentVersionQueryCommitsRequest) Execute() (*CommitDataPaginator, *http.Response, error) {
	return r.ApiService.ComponentVersionQueryCommitsExecute(r)
}

/*
ComponentVersionQueryCommits Get commits for this component version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organization Organization Key
	@param project Project Key
	@param component Component key
	@param version Component version
	@return ApiComponentVersionQueryCommitsRequest
*/
func (a *ComponentsApiService) ComponentVersionQueryCommits(ctx context.Context, organization string, project string, component string, version string) ApiComponentVersionQueryCommitsRequest {
	return ApiComponentVersionQueryCommitsRequest{
		ApiService:   a,
		ctx:          ctx,
		organization: organization,
		project:      project,
		component:    component,
		version:      version,
	}
}

// Execute executes the request
//
//	@return CommitDataPaginator
func (a *ComponentsApiService) ComponentVersionQueryCommitsExecute(r ApiComponentVersionQueryCommitsRequest) (*CommitDataPaginator, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CommitDataPaginator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentsApiService.ComponentVersionQueryCommits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organization}/projects/{project}/components/{component}/versions/{version}/commits"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterToString(r.organization, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterToString(r.project, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterToString(r.component, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorUnauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
